package com.forbetter223.Sort;

import java.util.Arrays;

/**
 * 希尔排序
 * 在插入排序上演化而来得更简单的一个算法
 */
public class Shell {
    public static void main(String[] args){
        //sortBySwap(new int[]{8,9,1,7,2,3,5,4,6,0});
        /*
        分成 5 组
        i = 5
        j = 0
                [3, 9, 1, 7, 2, 8, 5, 4, 6, 0]
        i = 6
        j = 1
                [3, 5, 1, 7, 2, 8, 9, 4, 6, 0]
        i = 7
        j = 2
                [3, 5, 1, 7, 2, 8, 9, 4, 6, 0]
        i = 8
        j = 3
                [3, 5, 1, 6, 2, 8, 9, 4, 7, 0]
        i = 9
        j = 4
                [3, 5, 1, 6, 0, 8, 9, 4, 7, 2]
        分成 2 组
                i = 2
        j = 0
                [1, 5, 3, 6, 0, 8, 9, 4, 7, 2]
        i = 3
        j = 1
                [1, 5, 3, 6, 0, 8, 9, 4, 7, 2]
        i = 4
        j = 2
                [1, 5, 0, 6, 3, 8, 9, 4, 7, 2]
        j = 0
                [0, 5, 1, 6, 3, 8, 9, 4, 7, 2]
        i = 5
        j = 3
                [0, 5, 1, 6, 3, 8, 9, 4, 7, 2]
        j = 1
                [0, 5, 1, 6, 3, 8, 9, 4, 7, 2]
        i = 6
        j = 4
                [0, 5, 1, 6, 3, 8, 9, 4, 7, 2]
        j = 2
                [0, 5, 1, 6, 3, 8, 9, 4, 7, 2]
        j = 0
                [0, 5, 1, 6, 3, 8, 9, 4, 7, 2]
        i = 7
        j = 5
                [0, 5, 1, 6, 3, 4, 9, 8, 7, 2]
        j = 3
                [0, 5, 1, 4, 3, 6, 9, 8, 7, 2]
        j = 1
                [0, 4, 1, 5, 3, 6, 9, 8, 7, 2]
        i = 8
        j = 6
                [0, 4, 1, 5, 3, 6, 7, 8, 9, 2]
        j = 4
                [0, 4, 1, 5, 3, 6, 7, 8, 9, 2]
        j = 2
                [0, 4, 1, 5, 3, 6, 7, 8, 9, 2]
        j = 0
                [0, 4, 1, 5, 3, 6, 7, 8, 9, 2]
        i = 9
        j = 7
                [0, 4, 1, 5, 3, 6, 7, 2, 9, 8]
        j = 5
                [0, 4, 1, 5, 3, 2, 7, 6, 9, 8]
        j = 3
                [0, 4, 1, 2, 3, 5, 7, 6, 9, 8]
        j = 1
                [0, 2, 1, 4, 3, 5, 7, 6, 9, 8]
        分成 1 组
                i = 1
        j = 0
                [0, 2, 1, 4, 3, 5, 7, 6, 9, 8]
        i = 2
        j = 1
                [0, 1, 2, 4, 3, 5, 7, 6, 9, 8]
        j = 0
                [0, 1, 2, 4, 3, 5, 7, 6, 9, 8]
        i = 3
        j = 2
                [0, 1, 2, 4, 3, 5, 7, 6, 9, 8]
        j = 1
                [0, 1, 2, 4, 3, 5, 7, 6, 9, 8]
        j = 0
                [0, 1, 2, 4, 3, 5, 7, 6, 9, 8]
        i = 4
        j = 3
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        j = 2
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        j = 1
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        j = 0
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        i = 5
        j = 4
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        j = 3
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        j = 2
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        j = 1
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        j = 0
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        i = 6
        j = 5
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        j = 4
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        j = 3
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        j = 2
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        j = 1
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        j = 0
                [0, 1, 2, 3, 4, 5, 7, 6, 9, 8]
        i = 7
        j = 6
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 5
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 4
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 3
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 2
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 1
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 0
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        i = 8
        j = 7
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 6
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 5
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 4
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 3
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 2
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 1
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        j = 0
                [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
        i = 9
        j = 8
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        j = 7
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        j = 6
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        j = 5
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        j = 4
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        j = 3
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        j = 2
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        j = 1
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        j = 0
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

         */
        sortByMove(new int[]{8,9,1,7,2,3,5,4,6,0});
    }


    /**
     * 用交换式实现希尔排序，元素互换
     * 这种方式比插入排序都慢。
     * 从小到大排序
     * 给定一个数组：8,9,1,7,2,3,5,4,6,0；
     * 1.先把数组分成（数组长度/2 = 5）组，也就是
     * [8,3],[9,5],[1,4],[7,6],[2,0]
     * 分组的概念是：在分成5组的时候，3只会和8进行比较，不会和8以外的数比较。
     * 2.每组里得两个比较，小的数替换大的数和它们的坐标
     * 第一轮结果：
     *  ①.3,x,x,x,x,8,x,x,x,x
     *  ②.3,5,x,x,x,8,9,x,x,x
     *  ③.3,5,1,x,x,8,9,4,x,x
     *  ④.3,5,1,6,x,8,9,4,7,x
     *  ⑤.3,5,1,6,0,8,9,4,7,2
     * 3.再把第一轮的结果分成5/2 = 2组，
     * 分组结果：
     * [3,1,0,9,7],[5,6,8,4,2]
     * 分组的概念是：在分成2组的时候，3只会和1,0,9,7进行比较，不会和它们以外的数比较。
     * 4.每组排序，小的数替换大的数和它们的坐标
     * 5.第二轮排序结果：
     *   0,2,1,4,3,5,7,6,9,8
     * 6.第三轮，把数组最终分成2/2 = 1组
     * 7.排序 0,2,1,4,3,5,7,6,9,8
     * 8.第三轮排序结果：
     *   0,1,2,3,4,5,6,7,8,9
     * @param params
     */
    private static void sortBySwap(int[] params){
        int temp = 0;
        // 给数组先进行分组，分组每次以上一次分组/2为递减条件.
        for(int group = params.length/2; group > 0; group /= 2){
            System.out.printf("分成 %d 组\n",group);
            // 主体循环
            for(int i = group; i < params.length; i++){
                // 每隔group的两个数相比较，参照注释第二步。
                // 比如 group = 5,数组下坐标0的元素和下坐标5的元素分成一组[8,3]
                // 规律是：3的下坐标0正好是8的下坐标5-group,所以j和i的联系是 j = i - group
                //        j管理分组的跃进,数组的下坐标最小是0，所以j必须>=0
                //        j循环的时候必须小于group 5,因为当j循环到下坐标为5的值3时，
                //        3已经和8成组,并且数组没有下坐标=10的值，所以j必须以-group为步长
                //        步长控制每隔多少个数的两个数进行比较
                System.out.printf("  i = %d \n", i);
                for(int j = i - group; j >= 0; j-=group){
                    System.out.printf("    j = %d \n", j);
                    // i的位置不变，所以要用j + group来确定间隔的两个数
                    if(params[j] > params[j + group]){
                        temp = params[j];
                        params[j] = params[j + group];
                        params[j + group] = temp;
                    }
                    System.out.println("      "+ Arrays.toString(params));
                }
            }
        }
    }

    /**
     * 移动的方式实现希尔排序，元素后移
     * 这种方式比插入排序快4倍左右
     * @param params 8,9,1,7,2,3,5,4,6,0
     */
    private static void sortByMove(int[] params){
        // 最外层循环不变，按组递减
        for(int group = params.length/2; group > 0; group /= 2){
            System.out.printf("按照 %d 分组\n",group);
            // 里面的循环按照插入排序的方法进行
            for(int i = group; i < params.length; i++){
                System.out.printf("  i = %d\n",i);
                int j = i;
                int temp = params[j];
                // 同组的元素相比较不小就没有必要位移
                if(params[j] < params[j - group]){
                    while(j - group >= 0 && temp < params[j - group]){
                        System.out.printf("    j = %d\n",j);
                        // 数组元素一次向后移动
                        params[j] = params[j - group];
                        j -= group;
                        System.out.printf("      %s\n",Arrays.toString(params));
                    }
                    // 当退出while循环后，当前的j就是temp插入的位置
                    params[j] = temp;
                }
            }
        }
    }
}
